<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ux_client_script">
    <sys_ux_client_script action="INSERT_OR_UPDATE">
        <includes/>
        <macroponent display_value="On-Call Recommended">4145b4b547432110ff50249bd36d433e</macroponent>
        <name>onCallFlatToDeep</name>
        <preset/>
        <required_translations>[ ]</required_translations>
        <script><![CDATA[/**
 * @param {params} params
 * @param {api} params.api
 * @param {any} params.event
 * @param {any} params.imports
 * @param {ApiHelpers} params.helpers
 */
function handler({ api, event, helpers, imports }) {
	if (!api.data.oncall_groups_by_id.output)
		return;
	var onCallFlatData = api.data.oncall_groups_by_id.output.result;
	var onCallDeepData = flatToDeepRepeater(onCallFlatData);
	sortGroups(onCallDeepData);
	updateRecommendedLabel(onCallDeepData);
	api.setState('onCallFlatData', onCallFlatData);
	api.setState('onCallDeepData', onCallDeepData);
	
	if (onCallDeepData.length === 0) {
		api.emit('RECOMMENDED_GROUPS_LOADED', {'hideSearchLink': false});
	} else
		api.emit('RECOMMENDED_GROUPS_LOADED', {'hideSearchLink': true});

	function sortGroups(groups) {
		let recommendedGroupsData = api.data.get_recommended_groups.output.result;
		if (recommendedGroupsData)
			groups.sort((group1, group2) => {
				var group1Order = recommendedGroupsData[group1.group.sys_id].order;
				var group2Order = recommendedGroupsData[group2.group.sys_id].order;
				if (!group1Order || !group2Order)
				 return 1;
				if (group1Order == group2Order) {
					if (group1.group.name < group2.group.name)
						return -1;
					else if (group1.group.name > group2.group.name)
						return 1;
					else 0;
				}
				return group1Order - group2Order;
			});
	}

	function updateRecommendedLabel(recommendedGroups) {
		let recommendedGroupsData = api.data.get_recommended_groups.output.result;
		recommendedGroups.forEach((recommendedGroup) => {
			let group = recommendedGroupsData[recommendedGroup.group.sys_id];
			if (group && group.message)
				recommendedGroup.recommendedLabel = group.message;
			else recommendedGroup.recommendedLabel = "";
		})
	}

	function _deepDataAsObject(groups) {
		var data = {};

		Object.keys(groups).forEach(function (outerKey) {
			data[outerKey] = _deepCopy(groups[outerKey]);
		});

		return data;
	}

	function _deepDataAsArray(groups) {
		var data = [];

		Object.keys(groups).forEach(function (outerKey) {
			data.push(_deepCopy(groups[outerKey]));
		});

		return data;
	}

	function _deepDataAsRepeater(groups) {
		var data = [];
		var toggleHideShifts = api.context.props.hideShiftsWithNoOnCall;
		Object.keys(groups).forEach(function (outerKey) {
			if (!toggleHideShifts || (groups[outerKey] && groups[outerKey].rota))
				data.push({ group: _deepCopy(groups[outerKey]) });
		});

		return data;
	}

	function _deepCopy(orig) {
		return JSON.parse(JSON.stringify(orig));
	}

	function _getDeepGroups(param) {
		if (!param || !param.onCallData)
			return {};

		var onCallData = param.onCallData;
		var groups = param.groups;
		var rotas = param.rotas;
		var rosters = param.rosters;
		var members = param.members;
		var users = param.users;

		var deepGroups = _deepCopy(groups);
		Object.keys(deepGroups).map(function(group) { deepGroups[group].active = false; });

		onCallData.forEach(function (onCallElem) {
			deepGroups[onCallElem.group].active = true;
			if (onCallElem.group && !deepGroups[onCallElem.group].rota)
				deepGroups[onCallElem.group].rota = rotas[onCallElem.rota];
			else if (onCallElem.group && deepGroups[onCallElem.group].rota && !deepGroups[onCallElem.group + '_' + onCallElem.rota] && deepGroups[onCallElem.group].rota && deepGroups[onCallElem.group].rota.sys_id !== onCallElem.rota) {
				var cloneGroupData = _deepCopy(deepGroups[onCallElem.group]);
				cloneGroupData.rota = rotas[onCallElem.rota];
				deepGroups[onCallElem.group + '_' + onCallElem.rota] = cloneGroupData;
			}

			var rotaRosters = rotas[onCallElem.rota].rosters;
			if (onCallElem.rota && !rotaRosters) {
				rotas[onCallElem.rota].rosters = [];
				rotas[onCallElem.rota].rosters.push(rosters[onCallElem.roster]);
			} else if ((onCallElem.rota && onCallElem.roster) && rotaRosters.indexOf(rosters[onCallElem.roster]) === -1)
				rotas[onCallElem.rota].rosters.push(rosters[onCallElem.roster]);

			if (onCallElem.roster && !rosters[onCallElem.roster].member) {
				rosters[onCallElem.roster].member = members[onCallElem.memberId];
				rosters[onCallElem.roster].member.user = users[onCallElem.userId];
				rosters[onCallElem.roster].member.user.displayName = rosters[onCallElem.roster].member.user.name;
			}
		});

		return deepGroups;
	}

	function _getRepeaterGroups(param) {
		if (!param || !param.onCallData)
			return {};

		var onCallData = param.onCallData;
		var groups = param.groups;
		var rotas = param.rotas;
		var rosters = param.rosters;
		var members = param.members;
		var users = param.users;

		var deepGroups = _deepCopy(groups);
		Object.keys(deepGroups).map(function(group) { deepGroups[group].active = false; });

		onCallData.forEach(function (onCallElem) {
			deepGroups[onCallElem.group].active = true;
			if (onCallElem.group && !deepGroups[onCallElem.group].rota)
				deepGroups[onCallElem.group].rota = rotas[onCallElem.rota];
			else if (onCallElem.group && deepGroups[onCallElem.group].rota && !deepGroups[onCallElem.group + '_' + onCallElem.rota] && deepGroups[onCallElem.group].rota && deepGroups[onCallElem.group].rota.sys_id !== onCallElem.rota) {
				var cloneGroupData = _deepCopy(deepGroups[onCallElem.group]);
				cloneGroupData.rota = rotas[onCallElem.rota];
				deepGroups[onCallElem.group + '_' + onCallElem.rota] = cloneGroupData;
			}

			var rotaRosters = rotas[onCallElem.rota].rosters;
			if (onCallElem.rota && !rotaRosters) {
				rotas[onCallElem.rota].rosters = [];
				rotas[onCallElem.rota].rosters.push({ roster: rosters[onCallElem.roster] });
			} else if (onCallElem.rota && rotaRosters) {
				var hasRosters = rotaRosters.filter(function (roster) {
					return roster.roster.sys_id === onCallElem.roster;
				});

				// limit to two rosters
				if (hasRosters.length === 0 && rotas[onCallElem.rota].rosters.length < 2)
					rotas[onCallElem.rota].rosters.push({ roster: rosters[onCallElem.roster] });
			}

			if (onCallElem.roster && !rosters[onCallElem.roster].member) {
				rosters[onCallElem.roster].member = members[onCallElem.memberId];
				rosters[onCallElem.roster].member.user = users[onCallElem.userId];
				rosters[onCallElem.roster].member.user.displayName = rosters[onCallElem.roster].member.user.name;
			}
		});

		return deepGroups;
	}

	function flatToDeepDataObject(flatDataModel) {
		return _deepDataAsObject(_getDeepGroups(flatDataModel));
	}

	function flatToDeepDataArray(flatDataModel) {
		return _deepDataAsArray(_getDeepGroups(flatDataModel));
	}

	function flatToDeepRepeater(flatDataModel) {
		var repeaterDataModel = _deepDataAsRepeater(_getRepeaterGroups(flatDataModel));
		return repeaterDataModel;
	}

}]]></script>
        <script_api_version>2.0.0</script_api_version>
        <sys_class_name>sys_ux_client_script</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2023-05-27 05:35:51</sys_created_on>
        <sys_id>1145b4b547432110ff50249bd36d43e1</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>onCallFlatToDeep</sys_name>
        <sys_package display_value="NeedIt" source="x_58872_needit">6ead8e780f603200cd674f8ce1050ed1</sys_package>
        <sys_policy/>
        <sys_scope display_value="NeedIt">6ead8e780f603200cd674f8ce1050ed1</sys_scope>
        <sys_update_name>sys_ux_client_script_1145b4b547432110ff50249bd36d43e1</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-05-27 05:35:51</sys_updated_on>
        <target>macroponent</target>
        <type>default</type>
    </sys_ux_client_script>
</record_update>
